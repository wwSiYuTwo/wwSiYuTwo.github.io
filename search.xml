<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JAVA NIO</title>
      <link href="/2020/05/31/java-nio/"/>
      <url>/2020/05/31/java-nio/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA-NIO"><a href="#JAVA-NIO" class="headerlink" title="JAVA NIO"></a>JAVA NIO</h1><h2 id="NIO-主要有三大核心部分：Channel-通道-，Buffer-缓冲区-Selector。"><a href="#NIO-主要有三大核心部分：Channel-通道-，Buffer-缓冲区-Selector。" class="headerlink" title="NIO 主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。"></a>NIO 主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。</h2><p><font color="gree">传统 IO 基于字节流和字<br>符流进行操作，而 NIO 基于 Channel 和 Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区<br>中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接打开，<br>数据到达）。因此，单个线程可以监听多个数据通道。</font>  </p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://i.loli.net/2020/05/31/4XIkbVDzmc9rS5R.png" alt="">  </p><h2 id="NIO-的缓冲区"><a href="#NIO-的缓冲区" class="headerlink" title="NIO 的缓冲区"></a>NIO 的缓冲区</h2><p>Java IO 面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何<br>地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓<br>存到一个缓冲区。NIO 的缓冲导向方法不同。数据读取到一个它稍后处理的缓冲区，需要时可在<br>缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所<br>有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的<br>数据  </p><h2 id="NIO-的非阻塞"><a href="#NIO-的非阻塞" class="headerlink" title="NIO 的非阻塞"></a>NIO 的非阻塞</h2><p>IO 的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write()时，该线程被阻塞，直到有<br>一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO 的非阻塞模式，<br>使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可<br>用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以<br>继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它<br>完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞 IO 的空闲时间用于在其它通道上<br>执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://i.loli.net/2020/05/31/sGZJaHuhX7MFmkn.png" alt="">  </p><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>首先说一下 Channel，国内大多翻译成“通道”。Channel 和 IO 中的 Stream(流)是差不多一个<br>等级的。只不过 Stream 是单向的，譬如：InputStream, OutputStream，而 Channel 是双向<br>的，既可以用来进行读操作，又可以用来进行写操作。<br>NIO 中的 Channel 的主要实现有：  <font color="green"></font></p><ol><li>FileChannel</li><li>DatagramChannel  </li><li>SocketChannel</li><li>ServerSocketChannel</li></ol><p>这里看名字就可以猜出个所以然来：分别可以对应文件 IO、UDP 和 TCP（Server 和 Client）。<br>下面演示的案例基本上就是围绕这 4 个类型的 Channel 进行陈述的。  </p><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>Buffer，故名思意，缓冲区，实际上是一个容器，是一个连续数组。Channel 提供从文件、<br>网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer。<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://i.loli.net/2020/05/31/Psegqak38wvIbnp.png" alt="">  </p><p>上面的图描述了从一个客户端向服务端发送数据，然后服务端接收数据的过程。客户端发送<br>数据时，必须先将数据存入 Buffer 中，然后将 Buffer 中的内容写入通道。服务端这边接收数据必须通过 Channel 将数据读入到 Buffer 中，然后再从 Buffer 中取出数据来处理。  </p><p>在 NIO 中，Buffer 是一个顶层父类，它是一个抽象类，常用的 Buffer 的子类有：<br>ByteBuffer、IntBuffer、 CharBuffer、 LongBuffer、 DoubleBuffer、FloatBuffer、<br>ShortBuffe  </p><h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>Selector 类是 NIO 的核心类，Selector 能够检测多个注册的通道上是否有事件发生，如果有事<br>件发生，便获取事件然后针对每个事件进行相应的响应处理。这样一来，只是用一个单线程就可<br>以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用<br>函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护<br>多个线程，并且避免了多线程之间的上下文切换导致的开销。  </p><hr><p><strong>完结…</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> NIO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
